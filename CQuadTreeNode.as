///////////////////////////////////////////////////////////
//  CQuadTreeNode.as
//  Macromedia ActionScript Implementation of the Class CQuadTreeNode
//  Generated by Enterprise Architect
//  Created on:      10-Nov-2009 6:51:02 PM
//  Original author: Kurniawan Fitriadi
///////////////////////////////////////////////////////////

package com.quadtree
{
	import flash.display.DisplayObjectContainer;
	
	import com.shade.ShadeCore;
	import com.shade.geom.Collision;
	import com.shade.geom.CRectangle;
	import com.quadtree.IGameObject;
	
		
	/**
	 * @author Kurniawan Fitriadi
	 * @version 1.0
	 * @created 10-Nov-2009 6:51:02 PM
	 */
	public class CQuadTreeNode
	{
   		private var m_level:int = 0;
		
		static private var m_root:CQuadTreeNode;
		private var m_parent: CQuadTreeNode = null;
	    private var m_subNodes: Array;

	    private var m_quadRect:CRectangle;
		
		static private var m_minSize: int;
	    static public var debug:Boolean = true;
		static private var m_conserveSubQuadrant:Boolean;
		
		private var m_itemCount:int = 0;

		private var m_debugQuad:CQuadTreeDebugBox;
	    /**
	     * The head of linked list items
	     */
	    private var m_listHead: CQuadTreeNodeContainer;
		private var m_listTail: CQuadTreeNodeContainer;

		/**
	     * 
	     * @param parent
	     * @param position
	     * @param size
	     * @param minSize    minSize
	     */
	    
		public function CQuadTreeNode() {}
		
		public function initialize( parent:CQuadTreeNode, pos_x:int, pos_y:int, 
									 size:int, minSize:int, conserveSubQuadrant:Boolean ):void 
		{
			if( parent == null ) 
				m_root = this
			else	
				m_parent = parent;
			
			m_quadRect = new CRectangle(pos_x, pos_y, size, size);
			
			m_subNodes = [];
			m_minSize = minSize;
			m_level = (!m_parent) ? 0 : m_parent.getLevel() + 1; 
			
			m_conserveSubQuadrant = conserveSubQuadrant; 
		}
		
		static public function get rootNode() : CQuadTreeNode
		{
			return m_root;
		}
		
		private function split(): void
	    {
			var size:int = m_quadRect.width >> 1;
			
			var node:CQuadTreeNode;
			
			node = ShadeCore.getInstance().poolManager.borrowItem(CQuadTreeNode);
			node.initialize(this, m_quadRect.x, m_quadRect.y, size, m_minSize, m_conserveSubQuadrant);
			m_subNodes.push( node );
			
			
			node = ShadeCore.getInstance().poolManager.borrowItem(CQuadTreeNode);
			node.initialize(this, m_quadRect.x + size, m_quadRect.y, size, m_minSize, m_conserveSubQuadrant);
			m_subNodes.push( node );
			
			node = ShadeCore.getInstance().poolManager.borrowItem(CQuadTreeNode);
			node.initialize(this, m_quadRect.x, m_quadRect.y + size, size, m_minSize, m_conserveSubQuadrant);
			m_subNodes.push( node );
			
			node = ShadeCore.getInstance().poolManager.borrowItem(CQuadTreeNode);
			node.initialize(this, m_quadRect.x + size, m_quadRect.y + size, size, m_minSize, m_conserveSubQuadrant);
			m_subNodes.push( node );
	    }
		
	    public function hasChilds(): Boolean
	    {
			return (m_subNodes.length > 0);
	    }

	    /**
	     * 
	     * @param index    index
	     */
	    public function getChildNode(index:int): CQuadTreeNode
	    {
			return ( hasChilds() ? CQuadTreeNode( m_subNodes[index] ) : null );
	    }

		public function getItemCount(): int
		{
			return m_itemCount;
		}
		
		// prepare to destroy
		public function _destroy():void
		{
			if( m_debugQuad != null ) 
			{
				m_debugQuad.parent.removeChild(m_debugQuad);
				m_debugQuad = null;
			}
		}
		
		/**
		 * if no nodes in this 
		 */
		private function unsplit(): void
		{
			if( (hasChilds()) &&
				(!getChildNode(0).hasChilds() && getChildNode(0).getItemCount() == 0) && 
				(!getChildNode(1).hasChilds() && getChildNode(1).getItemCount() == 0) &&
				(!getChildNode(2).hasChilds() && getChildNode(2).getItemCount() == 0) &&
				(!getChildNode(3).hasChilds() && getChildNode(3).getItemCount() == 0) )
			{
				for(var i:int; i < 4; i++)
				{
					var node:CQuadTreeNode = CQuadTreeNode(m_subNodes[i]);
					node._destroy();
					ShadeCore.getInstance().poolManager.recycleItem(CQuadTreeNode, node);
				}
				m_subNodes.splice(0, 4);
			}
		}

		public function getBoundRect() : CRectangle
		{
			return m_quadRect;
		}
		
		public function getLevel() : int
		{
			return m_level;
		}
		
		public function drawDebugQuad(display:DisplayObjectContainer):void 
		{
			if(!m_debugQuad)
				m_debugQuad = new CQuadTreeDebugBox( display, m_quadRect.x, m_quadRect.y, m_quadRect.width );

			m_debugQuad.paint();
					
			if(hasChilds()) {
				for(var i:int=0; i < 4; i++) {
					CQuadTreeNode(m_subNodes[i]).drawDebugQuad(display);
				}
			}
			else {
				m_debugQuad.drawSubNode(0xCCCCCC);	// if there are no subnodes then draw imaginary child
			}
		}
		
		/**
		 * 
		 * @param item    item
		 * @param buffer
		 */
		public function getCollidingItems(item:CQuadTreeNodeContainer, buffer:Array, flag:int, _checkDirection:int=0): int
		{
			var collidedItem:int = 0;
			
			// STEP 1 CHECK ITEMS ON THIS NODE
			var containerNode:CQuadTreeNodeContainer = m_listHead;
								
			while( containerNode != null ) 
			{
				if( containerNode != item )	// do not check same container
				{
					if( item.getBoundRect().intersects( containerNode.getBoundRect() ) ) 
					{
						// check filter
						var gameObject1:IGameObject = IGameObject( item.gameObject );
						var gameObject2:IGameObject = IGameObject( containerNode.gameObject );
						
						//if( gameObject1._testFilter( gameObject2, flag ) ) 
						if( gameObject1._queryCollisionFilter( gameObject2, flag ) ) 
						{
							buffer.push(containerNode.gameObject);	// put gameobject to list
						
							collidedItem++;
						}
					}
				}
								
				containerNode = containerNode.next;
			}
						
			// STEP 2 CHECK ITEMS ON EACH OF EVERY SUB QUADRANT
			if( _checkDirection >= 0 && hasChilds() ) 
			{
				for(var i:int=0; i < 4; i++) 
				{
					collidedItem += getChildNode(i).getCollidingItems(item, buffer, flag, 1);
				}
			}
						
			// STEP 3 CHECK ITEMS ON EACH PARENT QUADRANT
			if( _checkDirection <= 0 && m_parent != null ) 
			{
				collidedItem += m_parent.getCollidingItems(item, buffer, flag, -1);
			}
									
			return collidedItem;
		}
		
		public function getObjectsInRange(item:CQuadTreeNodeContainer, position_x:int, position_y:int, range:int, buffer:Array, flag:int): int
		{
			var inBoundItem:int = 0;
			
			/* step 1 - check bucket */

			var containerNode:CQuadTreeNodeContainer = m_listHead;
								
			while( containerNode != null ) 
			{
				if( containerNode != item )	// do not check same container
				{
					var box_rect:CRectangle = containerNode.getBoundRect(); 
					
					if( Collision.isBoxIntersectsCircle( box_rect.x, box_rect.y,
								 						 box_rect.width, box_rect.height,
												         position_x, position_y, range ) )
					{
						// check filter
						var gameObject1:IGameObject = IGameObject( item.gameObject );
						var gameObject2:IGameObject = IGameObject( containerNode.gameObject );
						
						//if( gameObject1._testFilter( gameObject2, flag ) ) 
						if( gameObject1._queryRangeFilter( gameObject2, flag ) ) 
						{
							buffer.push(gameObject2);		// add game object to list 
							
							inBoundItem++;
						}
					}
				}
				containerNode = containerNode.next;
			}
			
			/* step 2 - check sub nodes bucket */
			
			if( hasChilds() )
			{
				for(var i:int=0; i < 4; i++)
				{
					var sub_node:CQuadTreeNode = CQuadTreeNode( m_subNodes[i] );
					var sub_rect:CRectangle = sub_node.getBoundRect();
					
					if( Collision.isBoxIntersectsCircle( sub_rect.x, sub_rect.y,
								 						 sub_rect.width, sub_rect.height,
												         position_x, position_y, range ) )
					{
						inBoundItem += sub_node.getObjectsInRange(item, position_x, position_y, range, buffer, flag);
					}
				}
			}
			
			return inBoundItem;
		}

		/**
		 * Test if an object is possible to put on a sub quadrant, return quadrant index
		 * if succeed or -1  if not possible.
		 * 
		 * @param item    item
		 */
		private function testSubQuadrant(item:CQuadTreeNodeContainer): int
		{
			var quadSize:int = m_quadRect.width >> 1; 
					
			if( quadSize > m_minSize && 
			    quadSize > item.getBoundRect().width &&
				quadSize > item.getBoundRect().height ) 
			{
				
				var itemRect:CRectangle = item.getBoundRect();
				
				/* test for each four quadrants */
								
				// check quadrant 0
				if( Collision.isBoxInsideBox2( itemRect.x, itemRect.y, itemRect.width, itemRect.height, 
											   m_quadRect.x, m_quadRect.y, quadSize, quadSize ) )
				{
					return 0;
				}

				// check quadrant 1
				if( Collision.isBoxInsideBox2( itemRect.x, itemRect.y, itemRect.width, itemRect.height,
											   m_quadRect.x+quadSize, m_quadRect.y, quadSize, quadSize ) )
				{
					return 1;
				}
				
				// check quadrant 2
				if( Collision.isBoxInsideBox2( itemRect.x, itemRect.y, itemRect.width, itemRect.height, 
											   m_quadRect.x, m_quadRect.y+quadSize, quadSize, quadSize ) )
				{
					return 2;
				}
				
				// check quadrant 3
				if( Collision.isBoxInsideBox2( itemRect.x, itemRect.y, itemRect.width, itemRect.height,
											   m_quadRect.x+quadSize, m_quadRect.y+quadSize, quadSize, quadSize ) )
				{
					return 3
				}
			}
			
			return -1;
		}

		/**
		 * insert an item to the node return relevant QuadTreeNode where the object
		 * resides.
		 * 
		 * @param item    object
		 */
		public function insert(item:CQuadTreeNodeContainer): CQuadTreeNode
		{
			var quadrant:int = testSubQuadrant(item);
			if(quadrant >= 0) 
			{
				if( !hasChilds() )
					split();
				
				return CQuadTreeNode( m_subNodes[quadrant] ).insert(item);
			}
			addItem(item);
			
			return this; 
		}
		
		private function addItem(item:CQuadTreeNodeContainer):void
		{
			if( m_listHead == null )
			{
				m_listHead = item;
				m_listTail = item;
			}
			else 
			{
				m_listTail.next = item;
				item.prev = m_listTail;
				
				m_listTail = item;
			}
			
			item.quadTreeNode = this;
			m_itemCount++;
		}
				
		/**
		 * Remove reference of an item from this node.
		 * 
		 * @param item    item
		 */
		public function removeItem(item:CQuadTreeNodeContainer): void
		{
			if(item.prev == null)
			{
				if(item.next != null) {
					
					// this is the head
					m_listHead = item.next;
				    item.next.prev = null;
					item.next = null;
				}
				else {
					
					// this is the head and the tail
					m_listHead = null;
					m_listTail = null;
				}
			}
			else if(item.prev != null && item.next != null)
			{
				// this is a body
				item.prev.next = item.next;
				item.next.prev = item.prev;
				
				item.prev = null;
				item.next = null;
				
			}
			else if(item.next == null)
			{
				if(item.prev != null) {
					
					// this is the tail
					m_listTail = item.prev;
					item.prev.next = null;
					item.prev = null;
				}
			}
			item.quadTreeNode = null;
			
			m_itemCount--;
		}


		/**
		 * return a list of collided object against input node.
		 * 
		 * @param item    object
		 */
		public function query(item:CQuadTreeNodeContainer): Array
		{
			return null;
		}

		/**
		 * 
		 * @param sender
		 * @param item
		 */
		public function pushUp(sender:CQuadTreeNode, item:CQuadTreeNodeContainer): CQuadTreeNode
		{
			if( sender == this ) {
				removeItem(item);
				unsplit();		// try to unsplit
				return m_parent.pushUp(this, item);
			}
			
			if( !Collision.isBoxInsideBox(item.getBoundRect(), m_quadRect ) && m_parent != null ) {

				if( !m_conserveSubQuadrant )
					 unsplit();		// try to unsplit
					
				return m_parent.pushUp(this, item);
			}
			addItem(item);
			
			return this;
		}

		/**
		 * 
		 * @param sender
		 * @param item
		 */
		public function pushDown(sender:CQuadTreeNode, item:CQuadTreeNodeContainer): CQuadTreeNode
		{
			var quadrant:int = testSubQuadrant(item);
			if( quadrant >= 0 ) {

				if( !hasChilds() )
					split();
				
				if(sender == this)
					removeItem(item);
							
				return CQuadTreeNode(m_subNodes[quadrant]).pushDown(this, item);
			}
			
			if(sender != this)
				addItem(item);
							
			return this;
		}

		/**
		 * Each time a gameobject is moved, we must call this method to update object node,
		 * return new quadtreenode where this object resides.
		 * 
		 * @param item    item
		 */
		public function updateItem(item:CQuadTreeNodeContainer): CQuadTreeNode
		{
			// if object don't fit current quad bound and this node is not a root node then move up
			
			if( !Collision.isBoxInsideBox(item.getBoundRect(), m_quadRect) &&
				m_parent != null ) {
			
				return pushUp(this, item);
			}
			
			// check if object can be pushed down to this node's sub quadrant.
			return pushDown(this, item);
		}
	}//end CQuadTreeNode
}